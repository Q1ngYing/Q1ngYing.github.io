<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>深入EVM虚拟机-part3 | Q1ngying</title><meta name="author" content="Q1ngying"><meta name="copyright" content="Q1ngying"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#FFFFFF"><meta name="description" content="前言： 在第 3 部分中，将深入探讨合约存储的工作原理。通过提供一些思维模式来帮助理解并深入了解存储插槽包装">
<meta property="og:type" content="article">
<meta property="og:title" content="深入EVM虚拟机-part3">
<meta property="og:url" content="https://q1ngying.cn/EVMIntroPart3/index.html">
<meta property="og:site_name" content="Q1ngying">
<meta property="og:description" content="前言： 在第 3 部分中，将深入探讨合约存储的工作原理。通过提供一些思维模式来帮助理解并深入了解存储插槽包装">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://q1ngying.cn/img/butterfly-icon.jpg">
<meta property="article:published_time" content="2023-10-04T09:54:38.000Z">
<meta property="article:modified_time" content="2024-10-18T06:58:17.199Z">
<meta property="article:author" content="Q1ngying">
<meta property="article:tag" content="Solidity">
<meta property="article:tag" content="EVM">
<meta property="article:tag" content="EVM 学习">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://q1ngying.cn/img/butterfly-icon.jpg"><link rel="shortcut icon" href="/img/icons8-clover-ios-16-glyph-32.png"><link rel="canonical" href="https://q1ngying.cn/EVMIntroPart3/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><meta name="google-site-verification" content="IzCM4B791_p7IAU4WhRfiLlPBnODnamJ7ixKxzoeNfk"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        if (name && globalFn[key][name]) return
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#1b1b1b')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#FFFFFF')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"prismjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '深入EVM虚拟机-part3',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-10-18 14:58:17'
}</script><script charset="UTF-8" id="LA_COLLECT" src="//sdk.51.la/js-sdk-pro.min.js"></script><script>LA.init({id:"3Jzfa21KlLms3Lkh",ck:"3Jzfa21KlLms3Lkh"})</script><link rel="stylesheet" href="/css/style.css?1"><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/butterfly-icon.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">81</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">29</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">28</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-user"></i><span> 关于</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/back1.webp);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Q1ngying</span></a><a class="nav-page-title" href="/"><span class="site-name">深入EVM虚拟机-part3</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-user"></i><span> 关于</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><span> 友链</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">深入EVM虚拟机-part3</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-10-04T09:54:38.000Z" title="发表于 2023-10-04 17:54:38">2023-10-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-10-18T06:58:17.199Z" title="更新于 2024-10-18 14:58:17">2024-10-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Solidity/">Solidity</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/learn/">learn</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/EVM/">EVM</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>14分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><strong>前言：</strong> 在第 3 部分中，将深入探讨<strong>合约存储的工作原理</strong>。通过提供一些思维模式来帮助理解并深入了解<strong>存储插槽包装</strong></p>
<span id="more"></span>
<h1 id="存储基础"><a href="#存储基础" class="headerlink" title="存储基础"></a>存储基础</h1><p>在 <a target="_blank" rel="noopener" href="https://programtheblockchain.com/posts/2018/03/09/understanding-ethereum-smart-contract-storage">Program the Blockchain</a>这篇文章中，对存储基础知识进行了高度概括，建议可以先阅读这篇文章。</p>
<h2 id="1、数据结构"><a href="#1、数据结构" class="headerlink" title="1、数据结构"></a>1、数据结构</h2><p><strong>合约存储是一个简单的键值的映射</strong>。它将一个 32 字节的 key 映射到一个 32 字节的 value。鉴于我们的 key 是 32 字节大小，我们最多可以有（2^256）- 1 个 key</p>
<p><strong>所有的值都被初始化为 0，0没有被明确地存储。</strong>因为 <code>2^256</code> 大约是已知的、可观测的宇宙中的原子数量。没有一台计算机可以容纳这么多的数据。这也是将一个存储值设置为零的原因，因为该键值不再需要由网络上的结点存储，所以可以退还一些 gas。</p>
<p>从概念上讲，存储可以被看作是一个天文数字的大阵列。我们的第一个二进制值为 0 的 key 代表阵列中的第 0 项，二进制值为 1 的 key 代表阵列中的第 1 项，等等。</p>
<p><img src="https://raw.githubusercontent.com/Q1ngYing/images/master/images/image-20231004175726799.png" alt="image-20231004175726799"></p>
<h2 id="2、定长变量"><a href="#2、定长变量" class="headerlink" title="2、定长变量"></a>2、定长变量</h2><p><strong>被声明为存储变量的合约变量可以分为定长和不定长两种。</strong>我们将专注于定长变量，以及 EVM 如何将多个变量装入一个 32 字节的插槽中。要了解更多关于不定长变量，可以看 “Program the Blockchain” 的文章。</p>
<p>现在我们知道存储是一种键值映射，接下来的问题是知道：如何将 key 分配给 value。假设我们有如下的代码：</p>
<pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">contract</span> <span class="token class-name">StorageTest</span> <span class="token punctuation">&#123;</span>
	<span class="token builtin">uint256</span> value1<span class="token punctuation">;</span>
	<span class="token builtin">uint256</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> value2<span class="token punctuation">;</span>
	<span class="token builtin">uint256</span> value3<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>鉴于这些都是定长变量，EVM 可以使用保存的存储位置（keys），从插槽 0 （key 的二进制值为 0）开始，线性地向前移动到插槽 1、2 等。这是将根据变量在合约中的声明顺序来做的。第一个声明的存储变量将被存储在槽位 0。在这个例子中，插槽 0 将存放变量”value1”，变量”value2”是一个定长为 2 的数组，所以将占用插槽 1 和 插槽 2 ，最后插槽 3 将存放变量”value3”。</p>
<p><img src="https://raw.githubusercontent.com/Q1ngYing/images/master/images/640-16964106582043.png" alt="图片"></p>
<p>接下来再看另一个类型的合约，了解以下它的变量是如何存储的。</p>
<pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token keyword">contract</span> <span class="token class-name">StorageTest</span><span class="token punctuation">&#123;</span>
	<span class="token builtin">uint32</span> value1<span class="token punctuation">;</span>
	<span class="token builtin">uint32</span> value2<span class="token punctuation">;</span>
	<span class="token builtin">uint64</span> value3<span class="token punctuation">;</span>
	<span class="token builtin">uint128</span> value4<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个例子和上面的例子（占用 0~3 四个插槽）不同，这个例子只占用存储插槽 0，关键的区别在于<strong>用于变量的单位类型</strong>。之前所有的变量都是 <code>uint256</code> 类型，代表 32 个字节的数据。这里我们使用<code>uint32、uint64、uint128</code>分别代表 4、8、16 字节的数据。</p>
<h2 id="3、插槽包装"><a href="#3、插槽包装" class="headerlink" title="3、插槽包装"></a>3、插槽包装</h2><p>这就是插槽包装（slot packing）的由来。Solidity 编译器知道它可以在一个存储槽中存储 32 字节的数据。因此，当 “uint32 value1”，只占 4 个字节，被存储在插槽 0 时，当下一个变量被读入时，编译器会看它是否能被打包到当前的存储插槽。鉴于插槽 0 有 32 个字节的空间，而 value1 只占用了其中的 4 个字节，只要下一个变量的大小小于 28 个字节，它也将被装入插槽 0。在上面的例子中，我们从 0 存储插槽的 32 字节开始。</p>
<ul>
<li>value1 存储在插槽 0，占 4 个字节。</li>
<li>插槽 0 有 28 个字节的剩余空间</li>
<li>value2 是 4 个字节，小于 28 个字节，因此它可以被存储在插槽 0 中。</li>
<li>插槽 0 有 24 个字节的剩余</li>
<li>value3 是 8 个字节，小于 24 个字节，因此它也被存储插槽 0 中。</li>
<li>插槽 0 仍有 16 个字节的剩余</li>
<li>value4 是 16 个字节，正好等于 16 个字节，因此它仍被存储在插槽 0 中。</li>
</ul>
<p><em>需要注意的是：uint8 是最小的 Solidity 类型，因此在打包时不能小于 1 字节（8位）。</em></p>
<p>下图显示了插槽 0 中的 32 字节数据如何保存所有 4 个变量的：</p>
<p><img src="https://raw.githubusercontent.com/Q1ngYing/images/master/images/640-16964110953406.png" alt="图片"></p>
<h2 id="4、EVM-存储操作码"><a href="#4、EVM-存储操作码" class="headerlink" title="4、EVM 存储操作码"></a>4、EVM 存储操作码</h2><h3 id="1）SSTORE"><a href="#1）SSTORE" class="headerlink" title="1）SSTORE"></a>1）SSTORE</h3><p>SSTORE，他从调用栈中接收了一个 32 字节的键和一个 32 字节的值，并将 32 字节的值存储在该 32 字节的键位置。可以在 <a target="_blank" rel="noopener" href="https://noxx.substack.com/p/evm-deep-dives-the-path-to-shadowy-3ea#:~:text=location.%20Check%20out-,this,-EVM%20playground%20to">EVM PlayPlayground</a> 里查看它的运行原理。</p>
<p><img src="https://raw.githubusercontent.com/Q1ngYing/images/master/images/640-16964111921169.png" alt="图片"></p>
<h3 id="2）SLOAD"><a href="#2）SLOAD" class="headerlink" title="2）SLOAD"></a>2）SLOAD</h3><p>SLOAD，它从调用栈中接收一个 32 字节的键，并将存储在该 32 字节的键（key）位置的 32 字节的值（value）推到调用栈。可以在 <a target="_blank" rel="noopener" href="https://noxx.substack.com/p/evm-deep-dives-the-path-to-shadowy-3ea#:~:text=stack.%20Check%20out-,this,-EVM%20playground%20to">EVM PlayPlayground</a>里查看它的运行原理。</p>
<p><strong>如果 SSTORE 和 SLOAD 只处理 32 字节的值，那怎么能提取一个已经打包装入 32 字节插槽的变量呢？</strong></p>
<h1 id="存储和检索打包的变量"><a href="#存储和检索打包的变量" class="headerlink" title="存储和检索打包的变量"></a>存储和检索打包的变量</h1><p>下面用一个合约来仿照之前给出的例子。合约中我们增加了一个设置变量值的存储函数，它通过读取一个变量来进行一些运算操作。</p>
<pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token comment">//SPDX-License-Identifier: GPL-3.0</span>
<span class="token keyword">pragma</span> <span class="token keyword">solidity</span> <span class="token operator">>=</span><span class="token version number">0.7.0</span> <span class="token operator">&lt;</span><span class="token version number">0.9.0</span><span class="token punctuation">;</span>

<span class="token comment">/**
*@title Storage
*@dev Store &amp; retrieve value in a variable
*/</span>
<span class="token keyword">contract</span> <span class="token class-name">StorageTwo</span> <span class="token punctuation">&#123;</span>
	
	<span class="token builtin">uint32</span> value1<span class="token punctuation">;</span>
	<span class="token builtin">uint32</span> value2<span class="token punctuation">;</span>
	<span class="token builtin">uint64</span> value3<span class="token punctuation">;</span>
	<span class="token builtin">uint128</span> value4<span class="token punctuation">;</span>
	
	<span class="token keyword">function</span> <span class="token function">store</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">public</span> <span class="token punctuation">&#123;</span>
		value1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
		value2 <span class="token operator">=</span> <span class="token number">22</span><span class="token punctuation">;</span>
		value3 <span class="token operator">=</span> <span class="token number">333</span><span class="token punctuation">;</span>
		value4 <span class="token operator">=</span> <span class="token number">444</span><span class="token punctuation">;</span>
		
		<span class="token builtin">uint96</span> value5 <span class="token operator">=</span> value3 <span class="token operator">+</span> <span class="token builtin">uint32</span><span class="token punctuation">(</span><span class="token number">666</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>合约中的 store() 函数会执行前面我们存在疑问的操作。在一个插槽中存储多个变量而不覆盖现有数据，并从 32 字节的插槽中检索一个变量的特定字节。</p>
<p>让我们先看看插槽 0 的结束状态，下面是它的二进制和十六进制的表示。十六进制数字被机器识别为二进制数字，并且在 slot packing 中使用了一些位操作。 </p>
<p><img src="https://raw.githubusercontent.com/Q1ngYing/images/master/images/640-169641163841012.png" alt="图片"></p>
<p>十六进制的 0x115c 十进制表示为 4444，0x14d 为 333，0x16 为 22，0x01 为 1。这些对应于我们在 Solidity 代码中看到的 value 值。一个插槽可以容纳 32 个字节的数据，也就是说 64 个十六进制的字符或 256 位，正好容纳上面的 4 个变量。</p>
<h2 id="1、位运算"><a href="#1、位运算" class="headerlink" title="1、位运算"></a>1、位运算</h2><p>Slot packing 使用了 3 个位运算操作“AND、OR 和 NOT。对于 3 个具有相同命名的 EVM 操作码。</p>
<h3 id="1）AND"><a href="#1）AND" class="headerlink" title="1）AND"></a>1）AND</h3><p>在 AND 操作中，第一个数字的第一位与第二个数字的第一位进行比较。如果两个值都是 1.那么 AND 返回真，结果为 1，反之为 0，以此类推。</p>
<p><img src="https://raw.githubusercontent.com/Q1ngYing/images/master/images/640-169641211792415.png" alt="图片"></p>
<h3 id="2）OR"><a href="#2）OR" class="headerlink" title="2）OR"></a>2）OR</h3><p>在 OR 运算中，只要其中一个值为 1 就返回真，反之为 0。</p>
<p><img src="https://raw.githubusercontent.com/Q1ngYing/images/master/images/640-169641217516118.png" alt="图片"></p>
<h3 id="3）NOT"><a href="#3）NOT" class="headerlink" title="3）NOT"></a>3）NOT</h3><p>NOT 略有不同，他只接收一个值，而不是对 2 个数进行比较。NOT 对每个为进行逻辑否定，进行取反。</p>
<p>现在让我们来看看这些位运算操作是如何在上述例子中实际使用的。</p>
<h2 id="2、插槽操作-插槽包装-SSTORE"><a href="#2、插槽操作-插槽包装-SSTORE" class="headerlink" title="2、插槽操作-插槽包装 SSTORE"></a>2、插槽操作-插槽包装 SSTORE</h2><p>注意代码的第 10 行</p>
<pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity">value2 <span class="token operator">=</span> <span class="token number">22</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>此时 value1已经被存储在插槽 0 中，我们需要将一些额外的数据打包到同一个插槽中，其中 value3 和 value4 存储逻辑相同。我们将从理论上来解释这是如何做到的，并将提供一个 EVM playground 实例进一步探索。</p>
<p>从下面的值开始：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">0x00000016		&#x3D;	22 (value2)
0x00		    &#x3D;	0	(slot 0)
0x04			&#x3D;   4	(4 个字节，value2 的起始位置)
0x0100			&#x3D;	256	(1 字节的最大值 255 + 1)
0xffffffff		&#x3D;	4294967295 (二进制为 1 的大小为 4 个字节的数)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>0xffffffff 等于二进制的 11111111111111111111111111111111。EVM 做的第一件事是使用 EXP 操作码，它接收一个基数整数和一个指数，并返回结果数值。这里 0x0100 作为基整数，代表一个 1 字节的偏移量，指数为 0x04，其是 “value2” 的起始位置。下图显示了为什么返回的值是有用的。（0x100 的 0x04 次幂，也就是 0x100000000）</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">EXP 操作码产生值0x0000000000000000000000000000000000000000000000000000000100000000

如果用这个值乘以 value2，就会得到想要的值 0x016 在 32 字节插槽的位置。0x0000000000000000000000000000000000000000000000000000001600000000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>我们可以看到，EXP 函数的返回结果能够在正确的位置（4 字节偏移，插槽从右往左填充，相当于从右到左偏移八位）插入数据 0x16 。然而，我们还暂时不能写入这个值，因为它将覆盖已经被存储的 value1。这就是位掩码发挥的地方了。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">EXP 操作码产生值
0x0000000000000000000000000000000000000000000000000000000100000000

如果用这个值乘以 0xffffffff，可以得到 value2 所在的 4 个字节的位掩码。
0x000000000000000000000000000000000000000000000000ffffffff00000000

如果对这个值进行按位非运算，我们会得到一个除了 value2 所在的 4 个字节之外的所有字节的位掩码。
0xffffffffffffffffffffffffffffffffffffffffffffffff00000000ffffffff

在插槽 0 中使用 SSLOAD（注意值 value1 存在于返回的数据中）
0x0000000000000000000000000000000000000000000000000000000000000001

对插槽 0 中的数据和位掩码使用 AND 将返回分配给 value2 的 4 个字节之外的所有数据，并将位于 value2 的 4 个字节中的所有数据清零。
0x0000000000000000000000000000000000000000000000000000000000000001<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面显示了如何利用位掩码从一个插槽中获取除了待写入的数据外的所有的数据。在这个例子中，value2 所用的字节已经被设置为 0，但是如果没有被设置，这些数据就将会被抹去（位掩码：用一串二进制数字（掩码）去操作另一串二进制数字。这里及用 AND 操作码的与运算，通过 0 和其他数想与都为 0 的情况抹去不需要的数据）。</p>
<p>下面是另一个例子通过同样的过程，了解一下如果所有 4 个值都已经被存储，我们把 value2 从 22 更新到 99 会发生，现有的 0x016 值被清零。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">位掩码
0xffffffffffffffffffffffffffffffffffffffffffffffff00000000ffffffff

在存储所有值后在插槽 0 上使用 SSLOAD
0x0000000000000000000000000000115c000000000000014d0000001600000001

对插槽 0 中的数据和位掩码使用 AND 将向我们返回分配给 value2 的 4 个字节之外的所有数据，并将位于 value2 的 4 个字节中的所有数据清零
0x0000000000000000000000000000115c000000000000014d0000001600000001<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>看到这里，你可能已经在考虑按位或运算怎么样帮助组合我们已有的值了。步骤如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Value2
0x00000016

0xffffffff 的二进制表示为 4 字节全 1
0xffffffff

对 Value2 和 0xffffffff 进行按位与操作，确保如果提供的值大于4个字节，它将被裁剪下来
0x00000016

EXP 操作码产生值
0x0000000000000000000000000000000000000000000000000000000100000000

如果用这个值乘以 value2 ，我们将在 32 字节插槽中的正确位置得到我们想要的值 0x016 
0x0000000000000000000000000000000000000000000000000000001600000000

使用前一个位掩码部分的结果
0x0000000000000000000000000000000000000000000000000000000000000001

对前面的 2 个值使用按位或操作将 value2 存储在指定位置，同时保留已存储在插槽 0 中的所有值
0x0000000000000000000000000000000000000000000000000000001600000001<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>现在我们可以在插槽 0 的 32 字节值上使用 SSTORE，它包含了 value1 和 value2 在正确字节位置的数据。</p>
<h2 id="3、插槽操作-检索一个打包的变量-SLOAD"><a href="#3、插槽操作-检索一个打包的变量-SLOAD" class="headerlink" title="3、插槽操作 - 检索一个打包的变量 SLOAD"></a>3、插槽操作 - 检索一个打包的变量 SLOAD</h2><p>让我们来看第 22 行：</p>
<pre class="line-numbers language-solidity" data-language="solidity"><code class="language-solidity"><span class="token builtin">uint96</span> value5 <span class="token operator">=</span> value3 <span class="token operator">+</span> <span class="token builtin">uint32</span><span class="token punctuation">(</span><span class="token number">666</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>实际上我们只需要关心 value3 是怎么被检索到的。下面就是取出 value3 需要的数据的过程，我们用跟上边的不太一样的数据来展示。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">0x00                &#x3D;   0  (slot 0)
0x08                &#x3D;   8  (8 个字节，value3 的起始位置)
0x0100              &#x3D;   256 (1 字节的最大值 255 + 1)
0xffffffffffffffff  &#x3D;    (二进制全为 1 的大小为 8 个字节的数)
0x0000000000000000000000000000115c000000000000014d0000001600000001  &#x3D;   slot 0 value<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到大部分内容将在进行一些修改后被重新用于检索。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">0x0100 和 0x08 上的 EXP 操作码产量0x0000000000000000000000000000000000000000000000010000000000000000
存储插槽 0 上的 SSLOAD0x0000000000000000000000000000115c000000000000014d0000001600000001
DIV 操作码将插槽 0 的值除以 EXP 的值，这实际上是将 value1 和 value2 所使用的底部 8 个字节修剪掉。0x00000000000000000000000000000000000000000000115c000000000000014d
前 8 个字节的位掩码0x000000000000000000000000000000000000000000000000ffffffffffffffff
在此位掩码上使用 AND 和 DIV 的返回值有效地修剪&#x2F;清零前 16 个字节并返回给8 个字节的变量&quot;value3&quot;0x000000000000000000000000000000000000000000000000000000000000014d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们已经从包装的插槽 0 中检索到 value3。十六进制的 0x14d 十进制为 333，这就是我们在代码中所设定的。</p>
<p>位掩码和位操作再次被用来帮助从 32 字节的插槽中提取特定的字节。而这个值现在在栈中，然后可以被 EVM 用来计算 “value3 + uint32(666)”。</p>
<p>刚才探索的 store() 函数中执行的所有操作码都放到了 <a target="_blank" rel="noopener" href="https://noxx.substack.com/p/evm-deep-dives-the-path-to-shadowy-3ea#:~:text=them%20into%20an-,EVM%20playground,-.%20Here%20you%E2%80%99ll%20be">EVM Playgrpund 中</a>，代码如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; --------------------------------
&#x2F;&#x2F; Solidity Line 17 - &quot;value1 &#x3D; 1;&quot;
&#x2F;&#x2F; --------------------------------
PUSH1 0x01
PUSH1 0x00
DUP1
PUSH2 0x0100
EXP
DUP2
SLOAD
DUP2
PUSH4 0xffffffff
MUL
NOT
AND
SWAP1
DUP4
PUSH4 0xffffffff
AND
MUL
OR
SWAP1
SSTORE
POP

&#x2F;&#x2F; ---------------------------------
&#x2F;&#x2F; Solidity Line 18 - &quot;value2 &#x3D; 22;&quot;
&#x2F;&#x2F; ---------------------------------
PUSH1 0x16 &#x2F;&#x2F; value2 &#x3D; 22 decimal &#x3D; 0x16 in hex

PUSH1 0x00 &#x2F;&#x2F; slot 0 - storage location for &quot;value2&quot;

PUSH1 0x04 &#x2F;&#x2F; 4 bytes in - start position for &quot;value2&quot;

PUSH2 0x0100 &#x2F;&#x2F; 0x100 in hex &#x3D; 256 in decimal, 256 bits in 1 byte 

EXP &#x2F;&#x2F; exponent of 0x0100 &amp; 0x04 &#x3D; 0x100000000       
    
DUP2 &#x2F;&#x2F; duplicate 0x00 to top of stack

SLOAD &#x2F;&#x2F; load data at slot 0

DUP2 &#x2F;&#x2F; duplicate exponent of 0x0100 &amp; 0x04 &#x3D; 0x100000000

PUSH4 0xffffffff &#x2F;&#x2F; bitmask 4 bytes length      

MUL &#x2F;&#x2F; multiply to get bitmask for the 8 bytes assigned to &quot;value2&quot;

NOT &#x2F;&#x2F; NOT operation to get bitmask for all bytes except the 8 bytes assigned to &quot;value2&quot;

AND &#x2F;&#x2F; AND of bitmask and slot 0 value to zero out values in the 8 bytes assigned to &quot;value2&quot; and retain all other values

SWAP1 &#x2F;&#x2F; bring 0x100000000 to top of the stack

DUP4 &#x2F;&#x2F; duplicate value2 value &#x3D; 22 &#x3D; 0x16

PUSH4 0xffffffff &#x2F;&#x2F; bitmask 4 bytes length 

AND &#x2F;&#x2F; AND to ensure the value is no more than 4 bytes in length

MUL &#x2F;&#x2F; returns value2 at the correct position - 4 bytes in

OR &#x2F;&#x2F; OR with previous value and the value AND yielded on line 38 gives us the 32 bytes that need to be stored

SWAP1 &#x2F;&#x2F; slot 0 to top of the stack

SSTORE &#x2F;&#x2F; store the 32 byte value at slot 0

POP &#x2F;&#x2F; pop 0x16 off the stack

&#x2F;&#x2F; ----------------------------------
&#x2F;&#x2F; Solidity Line 19 - &quot;value3 &#x3D; 333;&quot;
&#x2F;&#x2F; ----------------------------------
PUSH2 0x014d
PUSH1 0x00
PUSH1 0x08
PUSH2 0x0100
EXP
DUP2
SLOAD
DUP2
PUSH8 0xffffffffffffffff
MUL
NOT
AND
SWAP1
DUP4
PUSH8 0xffffffffffffffff
AND
MUL
OR
SWAP1
SSTORE
POP

&#x2F;&#x2F; -----------------------------------
&#x2F;&#x2F; Solidity Line 20 - &quot;value4 &#x3D; 4444;&quot;
&#x2F;&#x2F; -----------------------------------
PUSH2 0x115c
PUSH1 0x00
PUSH1 0x10
PUSH2 0x0100
EXP
DUP2
SLOAD
DUP2
PUSH16 0xffffffffffffffffffffffffffffffff
MUL
NOT
AND
SWAP1
DUP4
PUSH16 0xffffffffffffffffffffffffffffffff
AND
MUL
OR
SWAP1
SSTORE
POP

&#x2F;&#x2F; ----------------------------------------------------------
&#x2F;&#x2F; Solidity Line 22 - &quot;uint64 value5 &#x3D; value3 + uint32(666);&quot;
&#x2F;&#x2F; ----------------------------------------------------------
PUSH1 0x00

PUSH2 0x029a &#x2F;&#x2F; uint32(666)

PUSH4 0xffffffff &#x2F;&#x2F; bitmask 4 bytes length

AND &#x2F;&#x2F; ensure uint32(666) does not exceed 8 bytes, trim if it does 

PUSH1 0x00 &#x2F;&#x2F; slot 0 - location of value3

PUSH1 0x08 &#x2F;&#x2F; 8 bytes in - start position for &quot;value3&quot;

SWAP1 &#x2F;&#x2F; bring 0x00 to top of stack for SLOAD of slot 0

SLOAD &#x2F;&#x2F; load data at slot 0

SWAP1 &#x2F;&#x2F; bring 0x08 to top of stack for EXP

PUSH2 0x0100 &#x2F;&#x2F; 256 bits in 1 byte 

EXP &#x2F;&#x2F; exponent of 0x0100 &amp; 0x08 &#x3D; 0x10000000000000000

SWAP1 &#x2F;&#x2F; get slot 0 value to top of stack

DIV &#x2F;&#x2F; DIV of slot 0 value with 0x10000000000000000 remove bottom 8 bytes  

PUSH8 0xffffffffffffffff &#x2F;&#x2F; bitmask 8 bytes length 

AND &#x2F;&#x2F; Zero out bytes outside of the 8 byte mask to return variable &quot;value3&quot;

&#x2F;&#x2F; To see the rest of the opcodes for this calculation recreate the contract in remix and enter debugging mode<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这篇文章我们深入了解存储插槽打包的工作原理，以及 EVM 是如何在 32 字节插槽的特定位置检索和存储字节的。尽管 EVM 的操作码 SLOAD &amp; SSTORE 只处理 32 字节的数据块，但我们可以使用位操作和位掩码来存储和加载我们想要的数据。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://q1ngying.cn">Q1ngying</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://q1ngying.cn/EVMIntroPart3/">https://q1ngying.cn/EVMIntroPart3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://q1ngying.cn" target="_blank">Q1ngying</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Solidity/">Solidity</a><a class="post-meta__tags" href="/tags/EVM/">EVM</a><a class="post-meta__tags" href="/tags/EVM-%E5%AD%A6%E4%B9%A0/">EVM 学习</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.jpg" data-sites="twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="prev-post pull-left" href="/EVMIntroPart4/" title="深入EVM虚拟机-part4"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">深入EVM虚拟机-part4</div></div></a><a class="next-post pull-right" href="/EVMIntroPart2/" title="深入EVM虚拟机-part2"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">深入EVM虚拟机-part2</div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a href="/EVMIntroPart1/" title="深入EVM虚拟机-part1"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-01</div><div class="title">深入EVM虚拟机-part1</div></div></a><a href="/EVMIntroPart2/" title="深入EVM虚拟机-part2"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-01</div><div class="title">深入EVM虚拟机-part2</div></div></a><a href="/EVMIntroPart4/" title="深入EVM虚拟机-part4"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-06</div><div class="title">深入EVM虚拟机-part4</div></div></a><a href="/EVMIntroPart5/" title="深入EVM虚拟机-part5"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-06</div><div class="title">深入EVM虚拟机-part5</div></div></a><a href="/EVMStorageStructure/" title="evm存储结构"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-14</div><div class="title">evm存储结构</div></div></a><a href="/Huff-1/" title="Huff(1)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-05</div><div class="title">Huff(1)</div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">存储基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.</span> <span class="toc-text">1、数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E5%AE%9A%E9%95%BF%E5%8F%98%E9%87%8F"><span class="toc-number">1.2.</span> <span class="toc-text">2、定长变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E6%8F%92%E6%A7%BD%E5%8C%85%E8%A3%85"><span class="toc-number">1.3.</span> <span class="toc-text">3、插槽包装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81EVM-%E5%AD%98%E5%82%A8%E6%93%8D%E4%BD%9C%E7%A0%81"><span class="toc-number">1.4.</span> <span class="toc-text">4、EVM 存储操作码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89SSTORE"><span class="toc-number">1.4.1.</span> <span class="toc-text">1）SSTORE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89SLOAD"><span class="toc-number">1.4.2.</span> <span class="toc-text">2）SLOAD</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%92%8C%E6%A3%80%E7%B4%A2%E6%89%93%E5%8C%85%E7%9A%84%E5%8F%98%E9%87%8F"><span class="toc-number">2.</span> <span class="toc-text">存储和检索打包的变量</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-number">2.1.</span> <span class="toc-text">1、位运算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89AND"><span class="toc-number">2.1.1.</span> <span class="toc-text">1）AND</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89OR"><span class="toc-number">2.1.2.</span> <span class="toc-text">2）OR</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89NOT"><span class="toc-number">2.1.3.</span> <span class="toc-text">3）NOT</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E6%8F%92%E6%A7%BD%E6%93%8D%E4%BD%9C-%E6%8F%92%E6%A7%BD%E5%8C%85%E8%A3%85-SSTORE"><span class="toc-number">2.2.</span> <span class="toc-text">2、插槽操作-插槽包装 SSTORE</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E6%8F%92%E6%A7%BD%E6%93%8D%E4%BD%9C-%E6%A3%80%E7%B4%A2%E4%B8%80%E4%B8%AA%E6%89%93%E5%8C%85%E7%9A%84%E5%8F%98%E9%87%8F-SLOAD"><span class="toc-number">2.3.</span> <span class="toc-text">3、插槽操作 - 检索一个打包的变量 SLOAD</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url(/img/back1.webp);"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By Q1ngying</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script>(() => {
  const panguFn = () => {
    if (typeof pangu === 'object') pangu.autoSpacingPage()
    else {
      btf.getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
        .then(() => {
          pangu.autoSpacingPage()
        })
    }
  }

  const panguInit = () => {
    if (false){
      GLOBAL_CONFIG_SITE.isPost && panguFn()
    } else {
      panguFn()
    }
  }

  btf.addGlobalFn('pjaxComplete', panguInit, 'pangu')
  document.addEventListener('DOMContentLoaded', panguInit)
})()</script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="17,185,200" opacity="0.8" zIndex="-1" count="200" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script></div></body></html>