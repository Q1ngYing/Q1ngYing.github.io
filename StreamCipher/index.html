<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>流密码 | Q1ngying</title><meta name="author" content="Q1ngying"><meta name="copyright" content="Q1ngying"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#FFFFFF"><meta name="description" content="根据德国 Christof Paar 的密码学基础教程学习了一些入门的密码学知识，本文对应其第二、三节内容，主要关于流密码，随机数生成器（RNG），一次性便签簿，线性同余生成器（LCG），线性反馈移位寄存器（LFSRs）以及针对LCG和LFSRs的攻击。">
<meta property="og:type" content="article">
<meta property="og:title" content="流密码">
<meta property="og:url" content="https://q1ngying.cn/StreamCipher/index.html">
<meta property="og:site_name" content="Q1ngying">
<meta property="og:description" content="根据德国 Christof Paar 的密码学基础教程学习了一些入门的密码学知识，本文对应其第二、三节内容，主要关于流密码，随机数生成器（RNG），一次性便签簿，线性同余生成器（LCG），线性反馈移位寄存器（LFSRs）以及针对LCG和LFSRs的攻击。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://q1ngying.cn/img/butterfly-icon.jpg">
<meta property="article:published_time" content="2024-03-29T13:18:52.000Z">
<meta property="article:modified_time" content="2024-10-18T07:30:02.600Z">
<meta property="article:author" content="Q1ngying">
<meta property="article:tag" content="密码学">
<meta property="article:tag" content="古典密码">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://q1ngying.cn/img/butterfly-icon.jpg"><link rel="shortcut icon" href="/img/icons8-clover-ios-16-glyph-32.png"><link rel="canonical" href="https://q1ngying.cn/StreamCipher/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><meta name="google-site-verification" content="IzCM4B791_p7IAU4WhRfiLlPBnODnamJ7ixKxzoeNfk"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        if (name && globalFn[key][name]) return
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#1b1b1b')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#FFFFFF')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"prismjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '流密码',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-10-18 15:30:02'
}</script><script charset="UTF-8" id="LA_COLLECT" src="//sdk.51.la/js-sdk-pro.min.js"></script><script>LA.init({id:"3Jzfa21KlLms3Lkh",ck:"3Jzfa21KlLms3Lkh"})</script><link rel="stylesheet" href="/css/style.css?1"><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/butterfly-icon.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">82</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">29</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">28</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-user"></i><span> 关于</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/back1.webp);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Q1ngying</span></a><a class="nav-page-title" href="/"><span class="site-name">流密码</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-user"></i><span> 关于</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><span> 友链</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">流密码</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-03-29T13:18:52.000Z" title="发表于 2024-03-29 21:18:52">2024-03-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-10-18T07:30:02.600Z" title="更新于 2024-10-18 15:30:02">2024-10-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/">密码学</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81/">古典密码</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>16分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="流密码（Stream-Ciphers）简介"><a href="#流密码（Stream-Ciphers）简介" class="headerlink" title="流密码（Stream Ciphers）简介"></a>流密码（Stream Ciphers）简介</h2><p>密码学（cryptography）可以分为三个分支：</p>
<ul>
<li>symm cryptography            对称密码学<ul>
<li>stream cryptography             流密码</li>
<li>block cryptography               分组密码</li>
</ul>
</li>
<li>asymm cryptography          非对称密码学</li>
<li>protocols  cryptography      协议密码学</li>
</ul>
<p>motivation（动机）</p>
<p>在我们传播一些信息时（如手机信号）我们需要对其进行加密：</p>
<p><img src="https://raw.githubusercontent.com/Q1ngYing/images/master/images/image-20240311204616816-171188855234910.png" alt="image-20240311204616816"></p>
<p>这个$\bigoplus$表示 <strong>模2</strong> 计算</p>
<p><img src="https://raw.githubusercontent.com/Q1ngYing/images/master/images/image-20240311210545513-171188855234911.png" alt="image-20240311210545513"></p>
<p>上述就是流密码的加密过程。</p>
<p><strong>定义</strong></p>
<p>什么是流密码？<strong>流密码对各个位进行单独加密</strong></p>
<p>在流密码中，我们用 <strong>s~i~</strong> 来代表密钥，而不是使用 <strong>k</strong> 。</p>
<script type="math/tex; mode=display">
encrypts:\ y_i=e(x_i) \equiv x_i+s_i \ mod \ 2 \\
decrypts:\ x_i=d(y_i) \equiv y_i+s_i \ mod \ 2</script><h3 id="问题一：为什么加密，解密都是使用的相同的运算符"><a href="#问题一：为什么加密，解密都是使用的相同的运算符" class="headerlink" title="问题一：为什么加密，解密都是使用的相同的运算符"></a>问题一：为什么加密，解密都是使用的相同的运算符</h3><script type="math/tex; mode=display">
d(y_i) \equiv y_i+s_i \ mod \ 2 \\
\equiv (x_i+s_i)+s_i \ mod \ 2 \\
\equiv x_i+2 \ s_i \ mod \ 2 \ \ \ \ \ \  \ \ \\
\equiv xi</script><p>上面的推导过程能够得到：<strong>mod 2 加法和减法是相同的运算</strong></p>
<p>所以，加密和解密使用的相同的运算符</p>
<script type="math/tex; mode=display">
x_i,y_i,s_i \in Z_2 = \{0,1\}</script><p>上述三者在 2 的整数环中（比特 bits）</p>
<p><strong>仔细观看 mod 2 情况下的相加：</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>x~i~</th>
<th>s~i~</th>
<th>y~i~</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td><strong>0</strong></td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td><strong>1</strong></td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td><strong>0</strong></td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td><strong>1</strong></td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<p>从上面的真值表可以看出，在电气工程中，这个是<strong>异或门</strong>，所以<strong>mod2 与 异或（XOR）是相同的</strong></p>
<p>继续观察，我们可以发现，当<code>key=0</code>时，明文的值<strong>没有变化</strong>，<code>key=1</code>时，明文的值发生了<strong>翻转</strong></p>
<h3 id="举例：ASCII加密”A”"><a href="#举例：ASCII加密”A”" class="headerlink" title="举例：ASCII加密”A”"></a>举例：ASCII加密”A”</h3><script type="math/tex; mode=display">
x_1 \ldots x_7=1000001 \\
S_1 \ldots s_7 = 0101101 \\
y_1 \ldots y_7 = 1101100\\</script><p>1101100对应的ASCII码时 <code>l</code> 也就是说，加密后的明文<code>A</code>在传输过程中被截获获取到的就变成了<code>l</code>。接下来对密文进行解密：</p>
<script type="math/tex; mode=display">
1101100 \\
0101101 \\
1000001</script><p>得到原来的明文<code>A</code></p>
<p>流密码看起来加密解密过程很简单，但是对实际生活确实产生了很大的帮助和影响，其实最难的是下面的问题</p>
<h3 id="问题：我们如何产生密钥S-i-的比特流？"><a href="#问题：我们如何产生密钥S-i-的比特流？" class="headerlink" title="问题：我们如何产生密钥S~i~的比特流？"></a><strong>问题：</strong>我们如何产生密钥S~i~的比特流？</h3><p><strong>某种程度上与随机性有关</strong></p>
<h2 id="随机数生成器（Random-Number-Generators-RNG"><a href="#随机数生成器（Random-Number-Generators-RNG" class="headerlink" title="随机数生成器（Random Number Generators:RNG)"></a>随机数生成器（Random Number Generators:RNG)</h2><p>我们区分 3 种类型的 RNGs：</p>
<ul>
<li>a)：真随机数生成器（True Random Number Generator：<strong>TRNG</strong>）<ul>
<li>真正的随机数源于随机物理过程，e.g. 抛硬币，彩票，噪音(热噪声)，鼠标移动，键盘输入时间间隔</li>
</ul>
</li>
<li>b)：伪随机数生成器（Pseudo Random Number Generators：<strong>PRNG</strong>）<ul>
<li>RNGs是计算来的，即他们是确定性的</li>
<li>通常他们是通过下面的函数被计算出来的</li>
<li>第一个随机数是种子值$s_0 = seed$（可能从某些地方传来，有时候这是一个真正的随机数）</li>
<li>然后接下来的随机数是通过递归计算来的$s_{i+1}=F(s_i)$</li>
</ul>
</li>
<li>c)：加密安全的伪随机数生成器（Cryptographically secure <strong>PRNGS</strong>：CPRNG）<ul>
<li>CPRNG 是 PRNG 的附加属性：数字<strong>不可预测</strong>（CPRNGs are PRNGs when an additional property: the numbers unpredictable）</li>
<li>非正式定义：<strong>给出 n 个输出位$S<em>1,S</em>{i+1}, \ldots ,S<em>{1+n-1}$计算上无法构建$S</em>{n}$</strong></li>
</ul>
</li>
</ul>
<h2 id="一次性便笺簿（One-Time-Pad）"><a href="#一次性便笺簿（One-Time-Pad）" class="headerlink" title="一次性便笺簿（One Time Pad）"></a>一次性便笺簿（One Time Pad）</h2><p>目标：构建一个”完美”的密码</p>
<p><strong>定义（完美密码）：</strong>一个密码是”无条件安全”（或信息在理论上是安全的）如果<strong>无限</strong>计算资源也无法破解</p>
<h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><p>One Time Pad（OTP）是一种流密码，其中</p>
<p>1) 密钥流比特来自 TRNG<br>2) 每个密钥流位仅使用一次</p>
<p><strong>最大缺点：密钥要和明文一样长</strong></p>
<p>举例：加密一个 400M 的文件 =&gt; 8*400 MB = 3.2 Gbit 的密钥</p>
<h2 id="线性同余生成器（Linear-Congruential-Generator：LCG-）"><a href="#线性同余生成器（Linear-Congruential-Generator：LCG-）" class="headerlink" title="线性同余生成器（Linear Congruential Generator：LCG  ）"></a>线性同余生成器（Linear Congruential Generator：LCG  ）</h2><p>idea：用一个密钥流$S_i$从一个PRNG</p>
<p><img src="https://raw.githubusercontent.com/Q1ngYing/images/master/images/image-20240320211248191-171188855234912.png" alt="image-20240320211248191"></p>
<p>上图就是如今流密码加密实现足够安全的方法。（M的意思是，假设是三十位的数字，那么A，B都是30 bit 长</p>
<p>虽然有一个很好的随机源（seed，A，B）但是在密码学上破解这个还是很容易的：</p>
<h3 id="Attack："><a href="#Attack：" class="headerlink" title="Attack："></a>Attack：</h3><p>Oscar 知道 $X_1,X_2,X_3$（比如文件头信息或者在消息加密中，有时有某种协议头）</p>
<ul>
<li><p>1)：Oscar 计算$S_1,S_2,S_3$</p>
</li>
<li><p>2)：计算$S_i \equiv A \cdot S_i+B \ mod \ m$（一个有两个参数的线性方程，我们需要的是<strong>两个未知数的二元一次方程组</strong>）</p>
<p>$S_3 \equiv A \cdot S_2 + B \ mod \ m$</p>
</li>
<li><p>当知道两个方程时，就能破解这个密码系统</p>
</li>
</ul>
<p>解决方法：</p>
<p><img src="https://raw.githubusercontent.com/Q1ngYing/images/master/images/image-20240320212907748-171188855234913.png" alt="image-20240320212907748"></p>
<p>也就是说：如果你知道三个随机数，就能破解 L</p>
<h2 id="线性反馈移位寄存器-Linear-Feedback-Shift-Registers-——-LFSRs-简介"><a href="#线性反馈移位寄存器-Linear-Feedback-Shift-Registers-——-LFSRs-简介" class="headerlink" title="线性反馈移位寄存器(Linear Feedback Shift Registers —— LFSRs)简介"></a>线性反馈移位寄存器(Linear Feedback Shift Registers —— LFSRs)简介</h2><p>Goal：流密码在硬件加密中是较小的（低功耗）</p>
<p>原子元素（电器工程）：触发器(flip-flop)存储1位（1 bit）</p>
<p><img src="https://raw.githubusercontent.com/Q1ngYing/images/master/images/image-20240327211346820-171188855234914.png" alt="image-20240327211346820"></p>
<p>一比特的输入，一比特的输出，然后有了时钟输入，时钟输入决定了什么时候存储比特</p>
<p>假设输入产生信号（下图<code>I</code>，但是时钟输入（clock input，下图<code>CLK</code>）没有输入，此时寄存器不会存储，直到时钟脉冲告诉寄存器，存储输入值（下图第一条虚线），此次存储器开始存储数据（对应的输入信号<code>I</code>是1，所以下图<code>O</code>上升），即使输入已经下降，输出元素保持不变，直到下次时钟脉冲，告诉寄存器存储输入值（这是刚好对应的输入是0），所以此时触发器的内容变成0</p>
<p><img src="https://raw.githubusercontent.com/Q1ngYing/images/master/images/image-20240327211945817-171188855234915.png" alt="image-20240327211945817"></p>
<p><strong>我们尝试去构建一个PRNG（通过触发器（flip-flop））：</strong></p>
<p>选择三个触发器，将他们连接起来，便得到了<strong>移位寄存器</strong>，然后得到了我们的输出信号（实际上所有的系统都需要某种初始状态，必须需要大量的触发器，并为他们分配一些初始值（不能全为0））。现在我们可以看到在我们的输出得到了0</p>
<p><img src="https://raw.githubusercontent.com/Q1ngYing/images/master/images/image-20240327212634402-171188855235017.png" alt="image-20240327212634402"></p>
<p>我们现在要做一些事情，否则Si保持为零。<strong>所以我们开始计时</strong>，这意味着我们产生了<strong>第一个时钟脉冲</strong>。假设我们在上图第二个触发器位置产生了一个时钟脉冲，这个触发器的输入是1，这意味着输出值变成了1，发生了右移（从最左边的触发器到中间的触发器），假设第三个触发器的位置也有一个时钟脉冲，它的输入值是0，所以他又一次把0移动存储到了第三个触发器。</p>
<p><img src="https://raw.githubusercontent.com/Q1ngYing/images/master/images/image-20240327213314749-171188855235020.png" alt="image-20240327213314749"></p>
<p>接着，第三个触发器处有一个时钟脉冲（它的输入值从0变为了1，因为第二个触发器的值在上一步变成了1），最后第三位我们得到了1。</p>
<p><img src="https://raw.githubusercontent.com/Q1ngYing/images/master/images/image-20240327213546517-171188855235016.png" alt="image-20240327213546517"></p>
<p>注意，此时上面的第二个触发器发生了什么我们不知道，因为第一个寄存器的输入是空的。</p>
<p><strong>所以，这是一个很愚蠢的随机数生成器，因为我们只能推出三位，我们用时钟脉冲打了三次，得到了三个输出位，game over，我们需要更聪明的随机数生成器，我们希望有一个长序列</strong></p>
<p>现在到底基本想法是：这是一个<strong>移位寄存器</strong>，就LFSR而言，我们现在只有S和R（Shift Registers），所以我们想在想要一个 <strong>Feedback</strong>（反馈），<strong>其基本思想是在每个时钟周期，我们为最后一个触发器（最左边的）产生一个新的输入</strong>。我们为最左边的触发器从其他的触发器”计算”一个新的输入。第一种从第一个触发器（最右边的）的输出和中间的触发器的输入异或，得到的结果作为最左边的触发器的输入：</p>
<p><img src="https://raw.githubusercontent.com/Q1ngYing/images/master/images/image-20240327214759550-171188855235018.png" alt="image-20240327214759550"></p>
<p>按照上面的规则，根据三个时钟循环，得到下面的数据：</p>
<p><img src="https://raw.githubusercontent.com/Q1ngYing/images/master/images/image-20240327215204509-171188855235019.png" alt="image-20240327215204509"></p>
<p>七个时钟循环，结果：</p>
<p><img src="https://raw.githubusercontent.com/Q1ngYing/images/master/images/image-20240327215859186-171188855235127.png" alt="image-20240327215859186"></p>
<p>如果我们从三位序列来看（对于三位来说有八个不同的三位值）我们有所有的三位值（少了一个0 0 0），但是当我们计算第八个的时候我们发现，他和第一个是一样的（如下图）我们陷入了一个太近的循环，在第七个时钟周期之后，他回到了第一个，这意味着这是一个周期性的（长度为7的周期），然后开始循环。</p>
<p><img src="https://raw.githubusercontent.com/Q1ngYing/images/master/images/image-20240327222112517-171188855235024.png" alt="image-20240327222112517"></p>
<p>上述所有的东西看起来像是电气工程之类的东西，但是后面是有相关数学理论支撑的</p>
<p><strong>数学公式表达</strong></p>
<script type="math/tex; mode=display">
s_3 \equiv s_1+s_0 \ mod \ 2 \\
s_4 \equiv s_2 + s_1 \ mod \ 2 \\
s_{i+3} \equiv  s_{i+1} + si \ mod \ 2\\</script><h2 id="常见的LFSRs"><a href="#常见的LFSRs" class="headerlink" title="常见的LFSRs"></a>常见的LFSRs</h2><p>我们首先可以操纵的第一件事就是从三个触发器增加到我们想要的数量的触发器。从三个增加数量后，需要注意<strong>增加后的触发器中，每一个触发器都有很大的机会和最后的随机数输出异或称为最后一个触发器的输入</strong></p>
<p>每个触发器都变成了一个开关，这些开关引入一个乘数（开关变量），我们将所有的触发器连接在一起（首先先构建成一个移位寄存器）然后再构建反馈网络（每次都是相同的，将输出结果和开关引入的乘数相乘得到X，所有的X来进行异或作为最后一个的输入）</p>
<p><img src="https://raw.githubusercontent.com/Q1ngYing/images/master/images/image-20240328084931631-171188855235021.png" alt="image-20240328084931631"></p>
<p>开关乘数的原理：</p>
<p><img src="https://raw.githubusercontent.com/Q1ngYing/images/master/images/image-20240328084844212-171188855235022.png" alt="image-20240328084844212"></p>
<p><strong>数学公式表达：</strong></p>
<script type="math/tex; mode=display">
S_m \equiv S_{m-1}P_{m-1} + S_{m-2}P_{m-2} + \dots + S_1P_1+S_0P_0 \ mod \ 2 \\
S_{m+1} \equiv S_{m}P_{m-1} + S_{m-1}P_{m-2} + \dots + S_2P_1+S_1P_0 \ mod \ 2</script><p>P~m~是不变的，但是S~m~总是递增的，这意味着<strong>现在得到了任何输出位的公式</strong></p>
<div>
$$
S_{m+i} \equiv \sum^{m-1}_{j=0} S_{i+j} \cdot P_{j} \mod \ 2 ,\ i=0,1,2
$$
</div>

<p>P 值是我们决定的（密码设计师决定的），不同的P值最后会得到很大区别的结果</p>
<p>在某段时间后，他会出现一个周期（一段时间后他会开始重复），比如我们上面三个LSR，周期就为7：</p>
<p><img src="https://raw.githubusercontent.com/Q1ngYing/images/master/images/image-20240328092626056-171188855235023.png" alt="image-20240328092626056"></p>
<p><strong>定理：m 次LFSR生成的最大周期（或序列长度）为$2^{m}-1$</strong></p>
<p><strong>定理仅适用于某些反馈配置(反馈配置是P的集合($P_{m-1}, \dots ,P_0$)才能产生最大长度序列</strong></p>
<p><strong>Example1：</strong>$m=4,P_3=P_2=0，P_1=P_0=1$</p>
<p>(P~0~是最左边的触发器，P~0~，P~1~=1，所以开关闭合，其他的P值为0，不闭合)</p>
<p><img src="https://raw.githubusercontent.com/Q1ngYing/images/master/images/image-20240328200424915-171188855235125.png" alt="image-20240328200424915"></p>
<p>它的最周期是 $2^4-1=15$</p>
<p><strong>Example2：</strong>$m=4,P_3=P_2=P_1=P_0=1$</p>
<p>凭直觉来说，这个例子看起来很复杂，但是从密码学上和统计学上，这种情况并不好，无论你的初值是多少，它实际的周期其实是 5 </p>
<p><img src="https://raw.githubusercontent.com/Q1ngYing/images/master/images/image-20240328200859073-171188855235126.png" alt="image-20240328200859073"></p>
<p>在数学中，不会给出上面这样的图像，一般是采用一种特殊的<strong>多项式</strong>来表示</p>
<p><strong>符号表示</strong>：LFSRs 通常由如下多项式表示</p>
<script type="math/tex; mode=display">
P(x)=x^m+P_{m-1}x^{m-1}+ \dots +P_1x+P_0</script><p>所以刚刚上面两个例子中的图，可以化为下面两个不同的多项式：</p>
<script type="math/tex; mode=display">
Ex1:\ X^4+X+1 \\
Ex2:\ X^4+X^3+X^2+X+1</script><p>当我们看到多项式时，如果告诉我们这是在讨论流密码和LFSRs，那么我们要想到刚刚两个例子的电路图，他们是一回事，是相同的。</p>
<p><strong>如果我们把他们当作多项式，我们可以通过多项式的性质，求出LFSRs何时具有最大长度</strong></p>
<p>如图，下面这些是<strong>原始多项式</strong>（LFSRs 最大长度的原始多项式）：</p>
<p><img src="https://raw.githubusercontent.com/Q1ngYing/images/master/images/image-20240328202240639-171188855235128.png" alt="image-20240328202240639"></p>
<p>通过上图，我们可以看到<code>(0,1,4)</code>这个多项式，对应我们上面的第一个例子，上面第一个例子对应的多项式也是<code>(0,1,4)</code>这个多项式，也就是上面第一个例子，是m=4的情况下，LFSRs最长的情况。</p>
<p><strong>只有具有“原始多项式”的 LFSRs 才能产生最大长度序列</strong></p>
<p>什么是原始多项式？粗略地说，他们和质数有关系</p>
<p>以下回答来自 ChatGPT-4：</p>
<blockquote>
<p>“Primitive polynomials” 在密码学中翻译成中文通常是“原始多项式”或“本原多项式”。它们在密码学、编码理论和有限域的理论中扮演着重要的角色。</p>
<p>原始多项式是有限域理论中的一个概念，特别是在构造有限域（也称为Galois域）时非常重要。一个有限域GF(p^n)，其中p是一个素数，n是一个正整数，可以通过取模一个不可约的多项式来构造，如果这个不可约多项式还是一个原始多项式，那么它可以生成该有限域的一个循环乘法群，这在密码学中是非常有用的。</p>
<h3 id="如何计算原始多项式："><a href="#如何计算原始多项式：" class="headerlink" title="如何计算原始多项式："></a>如何计算原始多项式：</h3><ol>
<li><strong>不可约性</strong>: 首先，一个原始多项式必须是不可约的，意味着它在其系数所在的有限域上不能被分解成更低次数的多项式的乘积。不可约多项式的判定可以通过多种算法实现，例如Berlekamp算法或Rabin测试。</li>
<li><strong>原始性测试</strong>: 对于一个给定的不可约多项式，要判断它是否是原始的，需要确保它的根是有限域GF(p^n)乘法群的生成元。这可以通过验证多项式的根α的各种幂次能够产生GF(p^n)中的所有非零元素来完成。一个有效的方法是，对于每个小于p^n - 1的正整数d，如果d是p^n - 1的因子，则验证α^d ≠ 1。</li>
</ol>
<h3 id="与什么有关系："><a href="#与什么有关系：" class="headerlink" title="与什么有关系："></a>与什么有关系：</h3><p>原始多项式与有限域的构造密切相关。有限域在密码学中有广泛应用，例如在椭圆曲线加密、伪随机数生成、编码理论（如Reed-Solomon编码）以及其他多种加密和数字签名算法中。</p>
<p>简而言之，原始多项式的选择对于有限域的性能和安全性至关重要，它们使得相关的加密系统既高效又安全。</p>
</blockquote>
<p>就目前的算力而言，当触发器数量为100时，最长的随机数数量是$2^{100}-1$。这是一个很大的数字，我们无法触发这个LFSRs的循环。但实际上，100个连续触发器是很短的。<strong>这意味着，使用移位寄存器，我们拥有一个非常好的构造超长序列的工具（用很少的硬件资源）</strong></p>
<p>上面是一个非常好的伪随机数生成器，但是在密码学上十分糟糕。</p>
<h2 id="针对单个-LFSRs-攻击"><a href="#针对单个-LFSRs-攻击" class="headerlink" title="针对单个 LFSRs 攻击"></a>针对单个 LFSRs 攻击</h2><p>Oscar goal：</p>
<p><img src="https://raw.githubusercontent.com/Q1ngYing/images/master/images/image-20240328213016717-171188855235129.png" alt="image-20240328213016717"></p>
<p>已知条件：</p>
<ul>
<li>所有的密文</li>
<li>m（如果不知道就需要猜，尝试所有的m的情况）</li>
<li>$x<em>0, \dots ,x</em>{2m-1}$（通过文件头）</li>
</ul>
<p>开始攻击：</p>
<p><strong>Step1：</strong></p>
<p>$y_i \equiv x_i+s_i \ mod \ 2$</p>
<p>$s_i \equiv y_i+x_i \ mod \ 2$</p>
<p>$i=0,1, \dots,2m-1 $</p>
<p><strong>Step2：</strong></p>
<p>Goal：恢复$S<em>{2m},S</em>{2m+1}, \dots$</p>
<p>Q：如果他有m，他缺少的是$P<em>i$开关的值$P_0=?,P_1=?,\dots,P</em>{m-1}=?$</p>
<p>我们要回去上面，利用上面的公式</p>
<p><img src="https://raw.githubusercontent.com/Q1ngYing/images/master/images/image-20240329103118183-171188855235130.png" alt="image-20240329103118183"></p>
<p><strong>我们想要p的方程，这些都是未知数，我们想最终得到某种公式或算法来解决这个问题。</strong>我们首先要写下一个方程，$S_m$是如何计算，我们取和上面完全相同的方程：</p>
<p>$S<em>m \equiv S</em>{m-1}P_{m-1}+ \dots + S_0P_0 \ mod \ 2$</p>
<p>我们有了一个方程，这里的未知数有$P_{m-1},\dots,P_0$，好的一面是我们有了一个包含所有未知数的方程，坏的一面是我们只有一个方程，一个m个未知数的线性方程。我们可以利用上面的公式（如下)求出其他的未知数方程：</p>
<p><img src="https://raw.githubusercontent.com/Q1ngYing/images/master/images/image-20241018152954573.png" alt="image-20241018152954573"></p>
<p>$S<em>{m+1} \equiv S</em>{m-1}P_{m-1}+ \dots +S_0P_0 \ mod \ 2$（未知数不会发生变化）</p>
<p>现在我们又得到了一个方程，虽然我们现在的方程还不够我们破解，但是我们可以继续一遍一遍的重复，直到能够解出未知数，直到：</p>
<p>$S<em>{2m-1} \equiv S</em>{2m-2}P<em>{m-1}+ \dots + S</em>{m-1}P_0 \ mod \ 2$</p>
<p><strong>m 个未知数的 m 个线性方程组可以通过高斯消去法（或矩阵求逆）轻松解决</strong></p>
<p>以下回答来自ChatGPT-4</p>
<blockquote>
<p>在密码学和许多其他领域，高斯消元法是解决线性方程组的一种基础和有效的方法。当你有$m$个未知数和$m$个线性方程时，你可以通过构建一个增广矩阵并使用高斯消元法来求解这个方程组，或者在需要时求出系数矩阵的逆矩阵。这种方法特别适用于需要找到确切解的情况，比如在密码学的某些算法分析中。</p>
<h3 id="步骤-1-构建增广矩阵"><a href="#步骤-1-构建增广矩阵" class="headerlink" title="步骤 1: 构建增广矩阵"></a>步骤 1: 构建增广矩阵</h3><p>假设你有以下$m$个线性方程组，其中包含$m$个未知数$x_1, x_2, …, x_m$：</p>
<script type="math/tex; mode=display">
\begin{align*}
a_{11}x_1 + a_{12}x_2 + \cdots + a_{1m}x_m &= b_1 \newline
a_{21}x_1 + a_{22}x_2 + \cdots + a_{2m}x_m &= b_2 \newline
\vdots \quad & \vdots \newline
a_{m1}x_1 + a_{m2}x_2 + \cdots + a_{mm}x_m &= b_m
\end{align*}</script><p>你首先构建一个增广矩阵$A|B$，其中$A$是系数矩阵，$B$是常数项列向量：</p>
<script type="math/tex; mode=display">
\begin{align*}
[A|B] = \left[\begin{array}{cccc|c}
a_{11} & a_{12} & \cdots & a_{1m} & b_1 \newline
a_{21} & a_{22} & \cdots & a_{2m} & b_2 \newline
\vdots & \vdots & \ddots & \vdots & \vdots \newline
a_{m1} & a_{m2} & \cdots & a_{mm} & b_m
\end{array}\right]
\end{align*}</script><h3 id="步骤-2-使用高斯消元法"><a href="#步骤-2-使用高斯消元法" class="headerlink" title="步骤 2: 使用高斯消元法"></a>步骤 2: 使用高斯消元法</h3><p>通过一系列的行操作（行交换、行乘以非零常数、行加上另一行的非零常数倍），你可以将增广矩阵转化为行最简形（或阶梯形）。这个过程分为两个主要部分：前向消元和回代。</p>
<ul>
<li><strong>前向消元</strong>：目标是将矩阵转换为上三角形式。你逐行进行，确保每一行的主元（该行最左侧的非零元素）下方的所有元素都是0。</li>
<li><strong>回代</strong>：一旦矩阵处于上三角形式，从最后一行开始向上回代，利用当前行的主元解出一个未知数，并将该值代回到上面的所有方程中，逐步解出所有未知数。</li>
</ul>
<h3 id="步骤-3-矩阵求逆（可选）"><a href="#步骤-3-矩阵求逆（可选）" class="headerlink" title="步骤 3: 矩阵求逆（可选）"></a>步骤 3: 矩阵求逆（可选）</h3><p>如果目的是求解系数矩阵$A$的逆，这在密码学中用于某些加密算法（如希尔密码）的解密过程，你可以将系数矩阵$A$和单位矩阵$I$放在一起形成增广矩阵$[A|I]$，然后对这个增广矩阵应用高斯消元法。最终，如果$A$是可逆的，你会得到一个形式为$[I|A^{-1}]$的矩阵，其中$A^{-1}$就是$A$的逆矩阵。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>不是所有矩阵都有逆矩阵。只有当矩阵$A$是方阵且行列式$\det(A) \neq 0$时，$A$才是可逆的。</li>
<li>在密码学应用中，特别是在模运算下解线性方程组时，所有计算（包括求逆）都需要在给定模数下进行。</li>
</ul>
<p>通过这种方法，高斯消元法为密码学提供了一种在理论和实践中都非常重要的工具，用于解决线性方程组，以及在某些情况下，帮助破解或分析加密算法。</p>
</blockquote>
<p><strong>如果攻击者（至少）知道 LFSR 的 2m 个输出值，他可以恢复整个 LFSR 配置</strong></p>
<p>当攻击者知道了$P_i$后，可以完全指定LFSR，即它可以自己构建LFSR，这里第三步是生成是生成所有</p>
<p><strong>Step3：</strong></p>
<ul>
<li>使用$P_{m-1},\dots,P_0$构建LFSR</li>
<li>计算$S<em>0,\dots\ ,S</em>{2m-}, S<em>{2m},S</em>{2m+1}, \dots$以此类推，计算整个输出</li>
<li>解码：$X_i\equiv Y_i+Si \ mod \ 2 \ \ \ \ i=0,1,2,\dots$</li>
</ul>
<p>有很长的序列长度，虽然从数据上看起来它们很好，很容易构建，但是在数学上有一些奇怪的描述，他们实际上并不安全。</p>
<p>但是可以用他们好几个，一起像积木一样堆叠起来来生成安全的密码</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://q1ngying.cn">Q1ngying</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://q1ngying.cn/StreamCipher/">https://q1ngying.cn/StreamCipher/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://q1ngying.cn" target="_blank">Q1ngying</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/">密码学</a><a class="post-meta__tags" href="/tags/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81/">古典密码</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.jpg" data-sites="twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="prev-post pull-left" href="/Reentrancy/" title="重入"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">重入</div></div></a><a class="next-post pull-right" href="/ModularArithmeticCaesarCipherAffineCipher/" title="密码-1：模运算，凯撒密码，仿射密码"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">密码-1：模运算，凯撒密码，仿射密码</div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a href="/ModularArithmeticCaesarCipherAffineCipher/" title="密码-1：模运算，凯撒密码，仿射密码"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-11</div><div class="title">密码-1：模运算，凯撒密码，仿射密码</div></div></a><a href="/CryptographyIntroduction/" title="密码引言"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-11</div><div class="title">密码引言</div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E5%AF%86%E7%A0%81%EF%BC%88Stream-Ciphers%EF%BC%89%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">流密码（Stream Ciphers）简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E4%B8%80%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8A%A0%E5%AF%86%EF%BC%8C%E8%A7%A3%E5%AF%86%E9%83%BD%E6%98%AF%E4%BD%BF%E7%94%A8%E7%9A%84%E7%9B%B8%E5%90%8C%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.1.</span> <span class="toc-text">问题一：为什么加密，解密都是使用的相同的运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B%EF%BC%9AASCII%E5%8A%A0%E5%AF%86%E2%80%9DA%E2%80%9D"><span class="toc-number">1.2.</span> <span class="toc-text">举例：ASCII加密”A”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%EF%BC%9A%E6%88%91%E4%BB%AC%E5%A6%82%E4%BD%95%E4%BA%A7%E7%94%9F%E5%AF%86%E9%92%A5S-i-%E7%9A%84%E6%AF%94%E7%89%B9%E6%B5%81%EF%BC%9F"><span class="toc-number">1.3.</span> <span class="toc-text">问题：我们如何产生密钥S~i~的比特流？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8%EF%BC%88Random-Number-Generators-RNG"><span class="toc-number">2.</span> <span class="toc-text">随机数生成器（Random Number Generators:RNG)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E6%AC%A1%E6%80%A7%E4%BE%BF%E7%AC%BA%E7%B0%BF%EF%BC%88One-Time-Pad%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">一次性便笺簿（One Time Pad）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%EF%BC%9A"><span class="toc-number">3.1.</span> <span class="toc-text">定义：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E5%90%8C%E4%BD%99%E7%94%9F%E6%88%90%E5%99%A8%EF%BC%88Linear-Congruential-Generator%EF%BC%9ALCG-%EF%BC%89"><span class="toc-number">4.</span> <span class="toc-text">线性同余生成器（Linear Congruential Generator：LCG  ）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Attack%EF%BC%9A"><span class="toc-number">4.1.</span> <span class="toc-text">Attack：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E5%8F%8D%E9%A6%88%E7%A7%BB%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8-Linear-Feedback-Shift-Registers-%E2%80%94%E2%80%94-LFSRs-%E7%AE%80%E4%BB%8B"><span class="toc-number">5.</span> <span class="toc-text">线性反馈移位寄存器(Linear Feedback Shift Registers —— LFSRs)简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84LFSRs"><span class="toc-number">6.</span> <span class="toc-text">常见的LFSRs</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E5%8E%9F%E5%A7%8B%E5%A4%9A%E9%A1%B9%E5%BC%8F%EF%BC%9A"><span class="toc-number">6.1.</span> <span class="toc-text">如何计算原始多项式：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E%E4%BB%80%E4%B9%88%E6%9C%89%E5%85%B3%E7%B3%BB%EF%BC%9A"><span class="toc-number">6.2.</span> <span class="toc-text">与什么有关系：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%92%88%E5%AF%B9%E5%8D%95%E4%B8%AA-LFSRs-%E6%94%BB%E5%87%BB"><span class="toc-number">7.</span> <span class="toc-text">针对单个 LFSRs 攻击</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-1-%E6%9E%84%E5%BB%BA%E5%A2%9E%E5%B9%BF%E7%9F%A9%E9%98%B5"><span class="toc-number">7.1.</span> <span class="toc-text">步骤 1: 构建增广矩阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-2-%E4%BD%BF%E7%94%A8%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%E6%B3%95"><span class="toc-number">7.2.</span> <span class="toc-text">步骤 2: 使用高斯消元法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-3-%E7%9F%A9%E9%98%B5%E6%B1%82%E9%80%86%EF%BC%88%E5%8F%AF%E9%80%89%EF%BC%89"><span class="toc-number">7.3.</span> <span class="toc-text">步骤 3: 矩阵求逆（可选）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">7.4.</span> <span class="toc-text">注意事项</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url(/img/back1.webp);"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By Q1ngying</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script>(() => {
  const panguFn = () => {
    if (typeof pangu === 'object') pangu.autoSpacingPage()
    else {
      btf.getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
        .then(() => {
          pangu.autoSpacingPage()
        })
    }
  }

  const panguInit = () => {
    if (false){
      GLOBAL_CONFIG_SITE.isPost && panguFn()
    } else {
      panguFn()
    }
  }

  btf.addGlobalFn('pjaxComplete', panguInit, 'pangu')
  document.addEventListener('DOMContentLoaded', panguInit)
})()</script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }
      
      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script></div><script id="canvas_nest" defer="defer" color="17,185,200" opacity="0.8" zIndex="-1" count="200" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script></div></body></html>